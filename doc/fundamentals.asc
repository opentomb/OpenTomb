The Fundamentals
----------------

Overview
~~~~~~~~

In this section, we'll try to describe basic file types of Tomb Raider, as well as data types used in the structures.

File types
^^^^^^^^^^

Tomb Raider is driven by various sets of files -- level files, script files, FMVs, audio tracks and sound files. In TR4 and TR5, there is also specific file
type which contains cutscene data -- _cutseq pack_.

The script files
++++++++++++++++

The script file structure differs from version to version.

In TR1, all script info was embedded into executable (`tomb.exe`) and thus is _hardcoded_. TR2 and TR3 had unified `TOMBPC.DAT` file, which contains all the
text strings describing the various elements in the game (e.g. the game engine knows about _``Key 1''_; it looks in `TOMBPC.DAT` to determine the name to be
displayed in Lara's inventory, such as _``Rusty Key''_ or _``Taste rostige''_ or _``Cle Rouillee''_), the level and cut-scene filenames (e.g. `WALL.TR2`,
`CUT3.TR2`), the order in which they are to be played, and various per-level and per-game configuration options (e.g. what weapons and objects Lara starts the
level with, whether or not the ``cheat'' codes work, etc.).

TR4 and TR5 introduced a new script format, where the actual script defining the gameflow was separated from text strings used in game -- hence, both TR4 and
TR5 have two `.DAT` files -- `SCRIPT.DAT` and `LANGUAGE.DAT`, where `LANGUAGE` differs depending on regional origin of the game -- `US.DAT`, `FRENCH.DAT`,
`JAPANESE.DAT`, and so on.

The level files
+++++++++++++++

The level files, `{level-name}.PHD/TUB/TR2/TR4/TRC`, contain everything about the level, including the geographical geometry, the geometry (meshes) of all
animate and inanimate objects in the level, all the textures and colour data, all animation data, index information (and, in TR1, TR4 and TR5 -- also the
_actual sound sample data_) for all sounds, accessibility maps -- everything necessary to run the game. For whatever reason, Core has included everything in one
file instead of breaking it up into logical groupings; this means that every level contains all the meshes, textures, sound information, and animation data for
Lara and all of her weapons. There are a fair number of other redundancies, too.

Since TR4, the level file is divided into _several chunks_, each of them being compressed with _zlib_. Usually, each chunk of compressed data is preceded by two
32-bit unsigned integers defining the _uncompressed size_ of the chunk and the _compressed size_ of the chunk. Therefore, the engine allocates an empty buffer
equal to the _uncompressed size_ of a specific chunk, and another buffer equal to the _compressed size_. The compressed data is loaded directly within it based
on the _compressed size_. The compressed data is then decompressed into the result buffer and the buffer containing the compressed data is destroyed.

It's good to note the origins of level file extension. While it is obvious that TR2/TR4/TRC extensions specify abbreviations of the game name. `.PHD` is
actually the initials of the _Lead Programmer_ for Tomb Raider 1: _Paul Howard Douglas_. Looks like this programmer contributed a lot of the code during early
development stages of Tomb Raider. This is suggested because the _phd_ initials also became a prefix for several helper functions in the original source code,
for instance: `phd_sin`, `phd_cos` etc. Most likely, he was also responsible for developing the level file structure for Tomb Raider.

FMVs (Full Motion Videos)
+++++++++++++++++++++++++

TR1-3 shared the same proprietary Eidos codec for videos, called _Escape_. The extension for such files is `.RPL`, that's why they occasionally (and
mistakingly) called Replay codec. Signature feature of RPL videos is that they are always interlaced with black stripes; most likely, this was used to conserve
disk space (however, _PlayStation_ videos were in `.STR` format, which is basic MPEG compression, and they had no interlacing -- but suffered from blocking
issues). In TR1 and TR2, framerate was limited to 15 FPS, while in TR3 it was doubled to 30 FPS.

For a long time, Escape codec was largely unexplored and barely reverse-engineered; there was only an abandoned open source _Mplayer_ implementation for some
Escape codec versions, but recent _ffmpeg_ revisions feature fully functional decoder for Escape videos.

Since TR4, all FMVs are in _Bink Video_ format, which is much more common and easy to rip, convert and explore.

Sound files -- audio tracks
+++++++++++++++++++++++++++

These are long sound files which occasionally play either on some in-game events (e.g. approaching certain important checkpoint in game, like big hall with ladder and two wolves in ``Caves'' -- it triggers danger music theme) or in looped manner as background ambience. Audio tracks are stored differently across TR game versions -- 'CD-Audio' in TR1-TR2, single merged file 'CDAUDIO.WAD' in TR3, and separate audio files in TR4 and TR5.

Sound files -- samples
++++++++++++++++++++++

TR2 and TR3 also featured external sound sample files, which allowed to share samples between all level files. This sound file is called `MAIN.SFX`, and usually
placed in `DATA` subfolder. Hence, engine loads sound samples not from level files (as it's done in TR1, TR4 and TR5 -- see above), but rather from this
`MAIN.SFX` file.

Cut sequence packs
++++++++++++++++++

TR4 and TR5 featured special data type containing all the necessary information to play _in-game cutscenes_. While in earlier games such info was embedded into
the level file itself, and generally, cutscenes themselves were separate level files (easily distinguished by their filenames, e.g. `CUT1.TR2` etc.), TR4
changed this approach, and cutscenes could be loaded and played right inside level files at runtime.

The data for such cutscene setup was packed into single file titled `CUTSEQ.PAK` in TR4 or `CUTSEQ.BIN` in TR5. There will be a special section describing whole
cutseq file format.

Basic data types
^^^^^^^^^^^^^^^^

For the purposes of further discussion, the following are assumed:

[width="70%",cols=">1,<5",align="center"]
|====
| `int8_t`    | specifies an 8-bit signed integer (range -128..127)
| `uint8_t`   | specifies an 8-bit unsigned integer (range 0..255)
| `int16_t`   | specifies a 16-bit signed integer (range -32768..32767)
| `uint16_t`  | specifies a 16-bit unsigned integer (range 0..65535)
| `int32_t`   | specifies a 32-bit signed integer (range -2147483648..2147483647)
| `uint32_t`  | specifies a 32-bit unsigned integer (range 0..4294967295)
| `float`     | specifies a 32-bit IEEE-754 floating-point number
| `fixed`     | specifies a 32.bit non-trivial 16.16 fixed point value -- see further
|====

All multi-byte integers (`{u}int16_t`, `{u}int32_t`) are stored in little-endian (Intel-x86, etc.) format, with the least significant byte stored first and the
most significant byte stored last. When using this data in platforms with big-endian (PowerPC, etc.) number format, be sure to reverse the order of bytes.

16.16 fixed point data type
+++++++++++++++++++++++++++

This very specific 32-bit data type mimics floating-point behaviour, _while remaining integer_. It is done by splitting floating-point value into whole and
fractional parts, and keeping each part as `int16_t` and `uint16_t` correspondingly. Whole part is kept as it is, while fractional part is multiplied by 65536,
and then kept as unsigned integer. So, the formula to calculate floating-point from mixed float is:

[width="100%",cols="^",frame="none",align="center"]
|====
|latexmath:[$F_{real} = P_{whole} + ( P_{frac} \div 65536 )$]
|====

...where latexmath:[$P_{whole}$] is whole part of mixed float (signed), and latexmath:[$P_{frac}$] is fractional part of mixed float.

[NOTE]
====
The reason why such complicated setup was invented is to avoid using floating-point numbers. In 90% of all cases, Tomb Raider engines use integer numbers, even
for geometry calculations and animation interpolations. The root of this setup lies in multi-platform nature of the code, which was simultaneously written for
PC and PlayStation. While PCs had enough computational power to deal with floats at that time, PlayStation relied only on integers.

However, some internal variables and constants (like drawing distance, fog distance constants and some light properties) are PC-specific and stored in floating
point numbers. Also, last game in series, TR5, extensively used floating-point numbers for certain data types -- like colours, vertices and coordinates.
====

Data alignment
++++++++++++++

Data alignment is something one has to be careful about. When some entity gets an address that is a multiple of latexmath:[$n$], it is said to be
latexmath:[$n$]-byte aligned. The reason it is important here is that some systems prefer multibyte alignment for multibyte quantities, and compilers for such
systems may pad the data to get the ``correct'' alignments, thus making the in-memory structures out of sync with their file counterparts. However, a compiler
may be commanded to use a lower level of alignment, one that will not cause padding. And for TR's data structures, 2-byte alignment should be successful in
nearly all cases, with exceptions noted below.

To set single-byte alignment in any recent compiler, use the following compiler directive:

[source,cpp]
--------------------------
#pragma pack(push, 1)
--------------------------

To return to the project's default alignment, use the following directive:

[source,cpp]
----------------------
#pragma pack(pop)
----------------------

Coordinates
^^^^^^^^^^^

The world coordinate system is oriented with the latexmath:[$X-Z$] plane horizontal and latexmath:[$Y$] vertical, with latexmath:[$-Y$] being ``up'' (e.g.
decreasing latexmath:[$Y$] values indicate increasing altitude). The world coordinate system is specified using `int32_t` values; however, the geography is
limited to the latexmath:[$+X$]/latexmath:[$+Z$] quadrant for reasons that are explained below. Mesh coordinates are relative and are specified using `int16_t`.

There are some additional coordinate values used, such as ``the number of 1024-unit blocks between points A and B'';  these are simply scaled versions of more
conventional coordinates.

Colours
^^^^^^^

All colours in TR are specified either explicitly (using either the <<tr_colour>> structure, described below, 16-bit structures or 32-bit structures) or
implicitly, by indexing one of the palettes. However, it is only applicable to TR1-3 -- there is no palette in TR4 and TR5.

In TR1-3, mesh surfaces could be either _coloured_ or _textured_. _Coloured_ surfaces are ``painted'' with a single colour that is either specified explicitly
or using an index into the palette.

Beginning from TR4, coloured faces feature was removed, so each face must have a texture attached to it.

Textures
^^^^^^^^

_Textured_ surfaces map textures (bitmapped images) from the texture tiles (textiles) to each point on the mesh surface.  This is done using conventional UV
mapping, which is specified in ``Object Textures'' below; each object texture specifies a mapping from a set of vertices to locations in the textile, and these
texture vertices are associated with position vertices specified here. Each textile is a 256x256 pixels wide area.

The 16-bit textile array, which contains <<tr_textile16>> structures, specifies colours using 16-bit ARGB, where the highest bit (`0x8000`) is a crude alpha
channel (really just simple transparency -- _0 = transparent_, _1 = opaque_).  The next 5 bits (`0x7c00`) specify the red channel, the next 5 bits (`0x03e0`)
specify the green channel, and the last 5 bits (`0x001f`) specify the blue channel, each on a scale from 0..31.

{TR1}{TR2}{TR3} If, for some reason, 16-bit textures are turned off, all colours and textures use an 8-bit palette that is stored in the level file.  This
palette consists of a 256-element array of <<tr_colour>> structures, each designating some colour;  textures and other elements that need to reference a colour
specify an index (0..255) into the `Palette[]` array.  There is also a 16-bit palette, which is used for identifying colours of solid polygons.  The 16-bit
palette contains up to 256 four-byte entries;  the first three bytes are a <<tr_colour>>, while the last byte is ignored (set to 0).

{TR4}{TR5} The 32-bit textile array, which contains <<tr4_textile32>> structures, specifies colours using 32-bit ARGB, where the highest byte is the alpha
channel (255 means the texel is fully opaque, 0 the texel is fully transparent).  The next bytes specify (in this order) the red / green / blue channels. The 16
and 32-bit textile arrays depict the same graphics data, but of course the 32-bit array has a better colour resolution. It's the one used if you select a 32
bits A8R8G8B8 texture format in the setup menu from TR4 and TR5.

Models
^^^^^^

There are two basic types of models in TR2 -- meshes and sprites.

_Meshes_ are collections of textured or coloured polygons that are assembled to form a three-dimensional object (such as a tree, a tiger, or Lara herself). The
``rooms'' themselves are also composed of meshes. Mesh objects may contain more than one mesh; though these meshes are moved relative to each other, each mesh
is rigid.

_Sprites_ are two-dimensional images that are inserted into three-dimensional space, such as the ``secret'' dragons, ammunition, medi-packs, etc. There are also
animated sprite sequences, such as the fire at the end of ``The Great Wall.'' Core had presumably used this method to reduce CPU utilization on the PlayStation
and/or the earlier PCs. Sprites become less and less abundant; TR2 has very few scenery sprites, and TR3's pickups are models instead of sprites.

Entities
^^^^^^^^

Each Tomb Raider game has an internal hardcoded set of _entity types_. Entity (or, in TRLE terms, a _moveable_) is an individual object with its own specific
function and purpose. Almost every ``moving'' or ``acting'' thing you see is an entity -- like enemies, doors, pick-up items, and even Lara herself.

A level can contain numerous instances of the same entity, e.g. ten crocodiles, five similar doors and switches, and so on.

Entities are referenced in one of two ways -- as an offset into an array (e.g. `Moveables[i]`) or using an identifying tag (`EntityID`). In the latter case, the
related array (`Items[]`, `Moveables[]`, etc.) is searched until a matching `EntityID` is found.

Animations
^^^^^^^^^^

There are three basic types of animations in TR, two corresponding with textures -- sprite animations and animated textures -- and one corresponding directly
with meshes.

Sprite animations
+++++++++++++++++

Sprite animation (sprite sequences) consists simply of a series of sprites that are to be displayed one after another, e.g. grenade explosions. Sprite
animations were quite common in earlier games (TR1 and TR2), while in TR3 onwards there are almost no sprite animations -- only notable example is fire particle
sprites and water splash effect.

Animated textures
+++++++++++++++++

These are either a list of textures cycled through in endless loop, or (in TR4-5) a single texture with shifting coordinates, creating an illusion of
``rolling'' image.

Mesh animations
+++++++++++++++

Mesh animations are much more complex than sprite and texture animations, and done by what is essentially a skeletal-modeling scheme. These involve some arrays
(Frames[] and MeshTree[]) of offsets and rotations for each element of a composite mesh. Frames are then grouped into an array (Animations[]) that describes
discrete ``movements'', e.g. Lara taking a step or a tiger striking with its paw. The animations are “sewn together” by a state change array and an animation
dispatch array, which, together with state information about the character, ensure that the animation is fluid (e.g. if Lara is running and the player releases
the RUN key, she will stop; depending upon which of her feet was down at the time, either her left or right foot will strike the floor as part of the ``stop''
animation. The correct animation (left foot stop vs. right foot stop) is selected using these structures and the state information).

Lighting
^^^^^^^^

There are two main types of lighting in Tomb Raider, _constant_ and _vertex_. Constant lighting means that all parts of an object have the same illumination,
while in vertex lighting, each polygon vertex has its own light value, and the illumination of the polygon interiors is interpolated from the vertex values.

Furthermore, lighting can be either internal or external. Internal lighting is specified in an object’s data, external lighting is calculated using the room’s
light sources (ambient light, point light sources, spotlights (TR4-5), dynamic lights).

When available, external lighting also uses the vertex normals to calculate the incoming light at each vertex. Light intensities are described either with a
single value or with a 16 bits color value (you can see it more like a ``color filter''), depending mainly on the TR version.

Light intensities are described with a single value in TR1 and a pair of values in TR2 and TR3; the paired values are almost always equal, and the pairing may
reflect some feature that was only imperfectly implemented, such as off/on or minimum/maximum values. In TR1 and TR2, the light values go from 0 (maximum light)
to 8192 (minimum light), while in TR3, the light values go from 0 (minimum light) to 32767 (maximum light).

Sound samples
^^^^^^^^^^^^^

There are two ways for sound samples to play.

First one is basically sound emitter sitting at a static global position in level, and continuously emitting specified sound (such as waterfalls -- these are in
`SoundSources[]`). Second one is triggered sounds -- these are sounds played when some event happens, such as at certain animation frames (footsteps and other
Lara sounds), when doors open and close, and when weapons are fired.

Either way, each played sound is referred to using a three-layer indexing scheme, to provide a maximum amount of abstraction. An internal sound index references
`SoundMap[]`, which points to a `SoundDetails[]` record, which in turn points to a `SampleIndices[]` entry, which in turn points to a sound sample.
`SoundDetails[]`, contains such features as sound intensity, how many sound samples to choose from, among others. The sound samples themselves are in Microsoft
WAVE format, and, as already mentioned, they are embedded either in the data files (TR1, TR4 and TR5) or in a separate file (`MAIN.SFX`) in TR2 and TR3.

Basic Data Structures
~~~~~~~~~~~~~~~~~~~~~

Much of the .TR2 file is comprised of structures based on a few fundamental data structures, described below.

Colour structure
^^^^^^^^^^^^^^^^

This is how most colours are specified.

[[tr_colour]]
[source,cpp]
----
struct tr_colour   // 3 bytes
{
    uint8_t Red;        // Red component (0 -- darkest, 255 -- brightest)
    uint8_t Green;      // Green component (0 -- darkest, 255 -- brightest)
    uint8_t Blue;       // Blue component (0 -- darkest, 255 -- brightest)
};
----
(Some compilers will pad this structure to make 4 bytes; one must either read and write 3 bytes explicitly, or else use a simple array of
bytes instead of this structure.)

And as mentioned earlier, the 16-bit palette uses a similar structure:

[source,cpp]
----
struct tr_colour4  // 4 bytes
{
    uint8_t Red;
    uint8_t Green;
    uint8_t Blue;
    uint8_t Unused;
};
----

In TR5, there is new additional colour type composed of floating-point numbers. This type is primarily used in light structures.

[source,cpp]
----
struct tr5_colour  // 4 bytes
{
    float Red;
    float Green;
    float Blue;
    float Unused;   // Usually filler value = 0xCDCDCDCD
};
----

Vertex structure
^^^^^^^^^^^^^^^^

This is how vertices are specified, using relative coordinates.  They are generally formed into lists, such that other entities (such as
quads or triangles) can refer to them by simply using their index in the list.

[source,cpp]
----
struct tr_vertex   // 6 bytes
{
    int16_t x;
    int16_t y;
    int16_t z;
};
----

As with colours, TR5 introduced additional vertex type comprised of floating-point numbers:

[source,cpp]
----
struct tr5_vertex   // 12 bytes
{
    float x;
    float y;
    float z;
};
----

Rectangular (quad) face definition
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Four vertices (the values are indices into the appropriate vertex list) and a texture (an index into the object-texture list) or colour (index into 8-bit
palette or 16-bit palette).  If the rectangle is a coloured polygon (not textured), the .Texture element contains two indices: the low byte (`Texture & 0xFF`)
is an index into the 256-colour palette, while the high byte (`Texture >> 8`) is in index into the 16-bit palette, when present. A textured rectangle will have
its vertices mapped onto all 4 vertices of an object texture, in appropriate correspondence.

[[tr_face4]]
[source,cpp]
----
struct tr_face4    // 12 bytes
{
    uint16_t Vertices[4];
    uint16_t Texture;
};
----

`Texture` field can have the bit 15 set: when it is, the face is _double-sided_ (i.e. visible from both sides).

{TR1}{TR2}{TR3} If the rectangle is a coloured polygon (not textured), the .Texture element contains two indices: the low byte (`Texture & 0xFF`) is an index
into the 256-colour palette, while the high byte (`Texture >> 8`) is in index into the 16-bit palette, when present.

TR4 and later introduced an extended version only used for meshes, not for triangles and quads making rooms:

[source,cpp]
----
struct tr4_mesh_face4    // 12 bytes
{
    uint16_t Vertices[4];
    uint16_t Texture;
    uint16_t Effects;
};
----

The only difference is the extra field `Effects`. It has this layout:

 * _Bit 0:_ if set, face has _additive alpha blending_ (same meaning that when the `Attribute` field of <<tr2_object_texture>> is 2, but this flag overrides it).

[width="80%",cols="^,^",frame="none",align="center"]
|====
| image:illustrations/face_blend.jpg[title="Bit 0 set"] | image:illustrations/face_noblend.jpg[title="Bit 0 not set"]
| _Bit 0 set, blending enabled_ | _Bit 0 not set, blending disabled_
|====

 * _Bits 1..7:_ strength of _environment mapping_ effect (so-called ``shiny effect'' in TRLE community). Environment map is derived from special pre-rendered
   texture. The bigger the value is, the more visible the effect is.

[width="40%",cols="^,^",frame="none",align="center"]
|====
| image:illustrations/shine-on.jpg[title="Bit 0 set"] | image:illustrations/shine-off.jpg[title="Bit 0 not set"]
| _Shiny effect at max_ | _No shiny effect_
|====

 . Note that only externally lit meshes can use environment mapping in original engines. If you use it with internally lit meshes, you will crash the game.
 . TR4 engine doesn't support environmental map for Lara's joints. It simply wasn't implemented, so if you apply effect to Lara joints, game will crash. For TR5,
   a special object called _Lara's catsuit_ was developed to support environmental map on transformed meshes.


Triangular face definition
^^^^^^^^^^^^^^^^^^^^^^^^^^

This structure has the same layout than the quad face definition, except a textured triangle will have its vertices mapped 'onto the first 3 vertices of an
object texture, in appropriate correspondence'. Moreover, a triangle has only 3 vertices, not 4.

[[tr_face3]]
[source,cpp]
----
struct tr_face3    // 8 bytes
{
    uint16_t Vertices[3];
    uint16_t Texture;
};

struct tr4_mesh_face3    // 10 bytes
{
    uint16_t Vertices[3];
    uint16_t Texture;
    uint16_t Effects;    // TR4-5 ONLY: alpha blending and environment mapping strength
};
----

All the info about `Texture` and `Effects` field is also similar to same info from <<tr_face4>> definition.

8-bit texture tile
^^^^^^^^^^^^^^^^^^

Each `uint8_t` represents a pixel whose colour is in the 8-bit palette.

[source,cpp]
----
struct tr_textile8    // 65536 bytes
{
    uint8_t Tile[256 * 256];
};
----

16-bit texture tile
^^^^^^^^^^^^^^^^^^^

Each `uint16_t` represents a pixel whose colour is of the form ARGB, MSB-to-LSB:

1-bit transparency (0 ::= transparent, 1 ::= opaque) (`0x8000`)  +
5-bit red channel (`0x7c00`)  +
5-bit green channel (`0x03e0`)  +
5-bit blue channel (`0x001f`)

[[tr_textile16]]
[source,cpp]
----
struct tr_textile16    // 131072 bytes
{
    uint16_t Tile[256 * 256];
};
----

32-bit texture tile
^^^^^^^^^^^^^^^^^^^

Each `uint32_t` represents a pixel whose colour is of the form ARGB, (A = most significant byte), each component being one byte.

[[tr4_textile32]]
[source,cpp]
----
struct tr4_textile32    // 262144 bytes
{
    uint32_t Tile[256 * 256];
};
----

Room Geometry
~~~~~~~~~~~~~

Overview
^^^^^^^^

A 'room' in TR2 is simply a rectangular three-dimensional area. A room may be ``indoors'' or ``outdoors,'' may or may not be enclosed, may be
accessible or inaccessible to Lara, may or may not contain doors or objects.

All rooms have ``portals,'' called ``doors'' in some documentation, which are pathways to adjacent rooms. There are two kinds of portals -- visibility portals
and collisional portals. Visibility portals are for determining how much of a room (if any) is visible from another room, while collisional portals are for
enabling an object to travel from one room to another.

The visibility portals are most likely for doing ``portal rendering'', which is a visibility-calculation scheme that goes as follows: the viewpoint is a member
of some room, which is then listed as visible from it. This room's portals are checked for visibility from that viewpoint, and visible portals have their
opposite-side rooms marked as visible. These rooms are then checked for portals that are visible from the viewpoint through the viewpoint's room's portals, and
visible ones have their opposite-side rooms marked as visible. This operation is repeated, with viewing through intermediate portals, until all visible portals
have been found. The result is a tree of rooms, starting from the viewpoint's room; only those rooms and their contents need to be rendered.

It is clear that both visibility and collision calculations require that objects have room memberships given for them, and indeed we shall find that most map
objects have room memberships.

Rooms may overlap; as we shall see, this is involved in how horizontal collisional portals are implemented. However, different rooms may overlap without either
being directly accessible from the other; there are several inadvertent examples of such ``5D space'' in the Tomb Raider series. The only possibly deliberate
example I know of is the flying saucer in ``Area 51'' in TR3, whose interior is bigger than its exterior.

A room can have an ``alternate room'' specified for it; that means that that room can be replaced by that alternate as the game is running. This trick is used
to produce such tricks as empty rooms vs. rooms full of water, scenery rearrangements (for example, the dynamited house in ``Bartoli's Hideout'' in TR2), and so
forth. An empty room is first created, and then a full room is created at its location from a copy of it. The empty room then has that full room set as its
alternate, and when that room is made to alternate, one sees a full room rather than an empty one.

The rooms are stored sequentially in an array, and ``Room Numbers'' are simply indices into this array (e.g. ``Room Number 5'' is simply `Rooms[5]`; the first
room is `Rooms[0]`).

Rooms are divided into _sectors_ (or _squares_), which are 1024x1024 unit squares that form a grid on the latexmath:[$X-Z$] plane. Sectors are the defining area
for floor/ceiling heights and triggers (e.g. a tiger appears and attacks when Lara steps on a given square); the various attributes of each sector are stored in
the Sector Data (described in this section) and the <<FloorData>>.  As an aside, Sectors correspond to the ``squares,'' easily visible in all of the Tomb Raider
games, that experienced players count when gauging jumps;  they also account for some of the game's less-appealing graphic artifacts. Careful tiling and texture
construction can make these ``squares'' almost invisible.

[NOTE]
====
Each room has two types of surface geometry -- 'rendered' and 'collisional'. The former are what is 'seen', while the latter control how objects 'collide' and
'interact' with the world. Furthermore, these two types are specified separately in the room data -- each type is 'completely independent of other', i. e.
collisional geometry shouldn't exactly match visible room geometry.

While this distinctive feature was never used in originals (collisional room ``meshes'' fully resembled visible room ``meshes''), it is now extensively used by
level editing community with the help of a program called 'meta2tr'. This utility allows level builder to replace visible geometry generated by 'TRLE' with any
custom geometry, usually modelled in 'Metasequoia' 3D editor (hence the name of 'meta2tr' utility).
====

Rooms are defined with a complex structure, which is described below ``inside-out,'' meaning that the smaller component structures are described first, followed
by the larger structures that are built using the smaller structures.

Room Structures
^^^^^^^^^^^^^^^

Room header
+++++++++++

latexmath:[$X / Z$] indicate the base position of the room mesh in world coordinates (latexmath:[$Y$] is always zero-relative)

[[tr_room_info]]
[source,cpp]
----
struct tr_room_info    // 16 bytes
{
    int32_t x;             // X-offset of room (world coordinates)
    int32_t y;             // Y-offset of room (world coordinates) - only in TR5
    int32_t z;             // Z-offset of room (world coordinates)
    int32_t yBottom;
    int32_t yTop;
};
----

`yBottom` is actually largest value, but indicates 'lowest' point in the room.
`yTop` is actually smallest value, but indicates 'highest' point in the room.

TR5 uses an extended version of this structure:

[source,cpp]
----
struct tr5_room_info    // 20 bytes
{
    int32_t x;             // X-offset of room (world coordinates)
    int32_t y;             // Y-offset of room (world coordinates) - only in TR5
    int32_t z;             // Z-offset of room (world coordinates)
    int32_t yBottom;
    int32_t yTop;
};
----

The additional `y` value is usually 0.

Portal structure
++++++++++++++++

These portals, sometimes called ``doors'', define the view from a room into another room. This can be through a ``real'' door, a window, or even some open area
that makes the rooms look like one big room. Note that ``rooms'' here are really just areas; they aren't necessarily enclosed.  The portal structure below
defines 'only visibility portals', not an actual moveable door mesh, texture, or action (if any).  And if the portal is not properly oriented, the camera cannot
``see'' through it.

[source,cpp]
----
struct tr_room_portal  // 32 bytes
{
    uint16_t  AdjoiningRoom; // Which room this portal leads to
    tr_vertex Normal;
    tr_vertex Vertices[4];
};
----

`Normal` field tells which way the portal faces (the normal points _away_ from the adjacent room; to be seen through, it must point _toward_ the viewpoint).

`Vertices` are the corners of this portal (the right-hand rule applies with respect to the normal). If the right-hand-rule is not followed, the portal will
contain visual artifacts instead of a viewport to `AdjoiningRoom`.

Room Sector structure
+++++++++++++++++++++

All the geometry specified here is 'collisional geometry'.

[source,cpp]
----
struct tr_room_sector // 8 bytes
{
    uint16_t FDindex;    // Index into FloorData[]
    uint16_t BoxIndex;   // Index into Boxes[] (-1 if none)
    uint8_t  RoomBelow;  // 255 is none
    int8_t   Floor;      // Absolute height of floor
    uint8_t  RoomAbove;  // 255 if none
    int8_t   Ceiling;    // Absolute height of ceiling
};
----

`Floor` and `Ceiling` are signed numbers of 256 units of height (relative to 0) -- e.g. Floor `0x04` corresponds to latexmath:[$Y = 1024$] in world coordinates.
Therefore, 256 units is a 'minimum vertical stride of collisional geometry'. However, this rule could be broken by specific entities, which Lara can stand on.
But 'horizontal' sector dimensions, which, as mentioned earlier, are 1024 x 1024 (in world coordinates), could not. Therefore, minimal horizontal platform
dimensions, on which Lara can stand and grab, are 1024 x 1024 as well.

NOTE: This implies that, while latexmath:[$X$] and latexmath:[$Z$] can be quite large, latexmath:[$Y$] is constrained to -32768..32512.

`Floor` and `Ceiling` value of `0x81` is a magic number used to indicate impenetrable walls around the sector. `Floor` values are used by the game engine to
determine what objects Lara can traverse and how. Relative steps of 1 (-256) can be walked up; steps of 2..7 (-512..-1792) can/must be jumped up; steps larger
than 7 (-2048..-32768) cannot be jumped up (too tall).

`RoomAbove` and `RoomBelow` values indicate what neighboring rooms are in these directions -- the number of the room below this one and the number of the room
above this one. If `RoomAbove` is not 'none', then the ceiling is a 'collisional portal' to that room, while if `RoomBelow` is not 'none', then the floor is a
'collisional portal' to that room.

Also, `RoomBelow` value is extensively used by engine to determine actual sector data and triggers in so-called 'stacked room setups', when one room is placed
above another through collisional portal. The thing is, engine uses sector data and triggers 'only for the lowest sector' of the stacked room setup, so it
recursively scans for a lowest room to determine which sector to use.

`FDindex` is a pointer to specific entry in <<FloorData>> array, which keeps all the information about sector flags, triggers and other parameters. While it is
implied that one `FDindex` entry may be shared between several sectors, it is usually not the case with original Tomb Raider levels built with 'TRLE'. However,
'Dxtre3d' takes advantage of this feature and may optimize similar sectors to share same FDindex pointer.

`BoxIndex` is a pointer to special <<Boxes>> array entry, which is basically a subset of sectors with same height configuration. It is primarily used for AI
pathfinding (see the <<non-player-character-behaviour,Non-player character behaviour>> chapter for more details).

{TR3}{TR4}{TR5} In these games, `BoxIndex` field is more complicated, and actually contains 'two packed values'. Bits 4..14 contain the 'actual box index', and
bits 0..3 contain 'material index', which is used to produce specific footstep sound, when Lara is walking or running in this sector. On PlayStation game
versions, this index was also used to determine if footprint textures should be applied to this particular place.

Majority of 'material index' values are the same across game versions, but some of them exist only in particular game. Here is the description:

* *0* -- Mud
* *1* -- Snow (TR3 and TR5 only)
* *2* -- Sand
* *3* -- Gravel
* *4* -- Ice (TR3 and TR5 only)
* *5* -- Water '(unused, as water footstep is only activated in water rooms)'
* *6* -- Stone '(unused, as it is default footstep sound)'
* *7* -- Wood
* *8* -- Metal
* *9* -- Marble (TR4 only)
* *10* -- Grass '(same sound effect as sand)'
* *11* -- Concrete '(same sound effect as stone, hence unused)'
* *12* -- Old wood '(same sound effect as wood)'
* *13* -- Old metal '(same sound effect as metal)'

Mud, snow, sand, grass and maybe some other materials produce footprints in PlayStation version.

Furthermore, in TR3-5, 'actual box index' may contain special value 2047, which is most likely indicates that this sector is a slope on which Lara can slide
(and, therefore, possibly impassable by most NPCs).

Room Light structure
++++++++++++++++++++

NOTE: TR engines always used static room lights only for processing lighting on entities (such as Lara, enemies, doors, and others). This is called 'external
lighting'. For room meshes, they used so-called 'internal, or 'pre-baked' lighting, which is done on level building stage: lights are calculated and applied to
room faces via vertex colours. There is no way to change room lighting when the level is compiled -- meaning, any changes in light positions, intensities and
colour won't affect room faces.

There are four different types of room light structures. First one is used in TR1-2, second is used in TR3, third is used in TR4, and fourth is used in TR5.
Here is the description of each:

.TR1-2 Room Lighting

[source,cpp]
----
struct tr_room_light   // 18 bytes (TR2: 24 bytes)
{
     int32_t x, y, z;       // Position of light, in world coordinates
    uint16_t Intensity1;    // Light intensity
    uint32_t Fade1;         // Falloff value
};
----

`X/Y/Z` are in world coordinates. `Intensity1/Intensity2` are almost always equal. This lighting only affects 'externally-lit' objects. Tomb Raider 1 has only
the first of the paired `Intensity` and `Fade` values.

`Intensity1` ranges from 0 (dark) to 0x1FFF (bright). However, some rooms occasionally have some lights with intensity greater than 0x1FFF (for example, look at
room #9, 2nd light in `level1.phd`). `Fade1` is the maximum distance the light shines on, and ranges from 0 to 0x7FFF.

TR2 uses an extended version of this structure:

[source,cpp]
----
struct tr2_room_light   // 24 bytes
{
     int32_t x, y, z;       // Position of light, in world coordinates
    uint16_t Intensity1;    // Light intensity
    uint16_t Intensity2;    // Only in TR2
    uint32_t Fade1;         // Falloff value
    uint32_t Fade2;         // Only in TR2
};
----

`Intensity2` and `Fade2` values are seemingly not used. `Intensity1` can go very well beyond 0x1FFF, right to 0x7FFF (ultra bright light). Above 0x7FFF, it is
always black, so the number is pseudo-signed (negative values are always treated as zero).

.TR3 Room Lighting

[source,cpp]
----
struct tr3_room_light   // 24 bytes
{
        int32_t x;             // Position of light, in world coordinates
        int32_t y;
        int32_t z;
     tr_colour4 Colour;        // Colour of the light
       uint32_t Intensity;
       uint32_t Fade;          // Falloff value
};
----

`Intensity` is the power of the light and ranges mainly from 0 (low power) to 0x1FFF (high power). Though, values greater than 0x1FFF do exist and their
meanings are unknown. `Fade` is the distance max the light can shine on. Range is mainly from 0 to 0x7FFF, but negative values do exist and their meanings are
unknown.

.TR4 Room Lighting

[source,cpp]
----
struct tr4_room_light   // 46 bytes
{
        int32_t x, y, z;       // Position of light, in world coordinates
      tr_colour Colour;        // Colour of the light

        uint8_t LightType;
        uint8_t Unknown;       // Always 0xFF?
        uint8_t Intensity;

          float In;            // Also called hotspot in TRLE manual
          float Out;           // Also called falloff in TRLE manual
          float Length;
          float CutOff;

          float dx, dy, dz;    // Direction - used only by sun and spot lights
};
----

`LightType` is somewhat similar to D3D light type, but there are some differences.

* *0* -- Sun
* *1* -- Light
* *2* -- Spot
* *3* -- Shadow
* *4* -- Fog bulb

[NOTE]
====
'Fog bulb' is a special case of room light, which actually don't work as usual light. It serves as a point in space, where a kind of 'volumetric fog' effect is
generated. It works only if user has enabled corresponding option in game setup.

Fog bulbs don't use `Colour` field to define its colour. However, `Red` field of a `Colour` structure is used to define fog density. Colour itself can be only
changed with special 'flipeffect #28' trigger function, which takes a value from the 'timer field' of the trigger to index into hardcoded RGB table of
pre-defined colours. The table consists of 28 RGB values:
====

[width="75%",cols="^,^,^,^",align="center"]
|=========================================================================
| 0 = 0,0,0       | 7 = 0,64,192     | 14 = 111,255,223 | 21 = 0,30,016
| 1 = 245,200,60  | 8 = 0,128,0      | 15 = 244,216,152 | 22 = 250,222,167
| 2 = 120,196,112 | 9 = 150,172,157  | 16 = 248,192,60  | 23 = 218,175,117
| 3 = 202,204,230 | 10 = 128,128,128 | 17 = 252,0,0     | 24 = 225,191,78
| 4 = 128,64,0    | 11 = 204,163,123 | 18 = 198,95,87   | 25 = 77,140,141
| 5 = 64,64,64    | 12 = 177,162,140 | 19 = 226,151,118 | 26 = 4,181,154
| 6 = 243,232,236 | 13 = 0,223,191   | 20 = 248,235,206 | 27 = 255,174,0
|=========================================================================

.TR5 Room Lighting

[source,cpp]
----
struct tr5_room_light   // 88 bytes
{
        float x, y, z;       // Position of light, in world coordinates
        float r, g, b;       // Colour of the light

       uint32_t Separator    // Dummy value = 0xCDCDCDCD

        float In;            // Cosine of the IN value for light / size of IN value
        float Out;           // Cosine of the OUT value for light / size of OUT value
        float RadIn;         // (IN radians) * 2
        float RadOut;        // (OUT radians) * 2
        float Range;         // Range of light

        float dx, dy, dz;    // Direction - used only by sun and spot lights
      int32_t x2, y2, z2;    // Same as position, only in integer.
      int32_t dx2, dy2, dz2; // Same as direction, only in integer.

      uint8_t LightType;

      uint8_t Filler[3];     // Dummy values = 3 x 0xCD
};
----

`x,y,z` values shouldn't be used by sun type light, but sun seems to have a large `x` value (9 million, give or take), a zero `y` value, and a small `z` value
(4..20) in the original TR5 levels.

`In` and `Out` values aren't used by 'sun' type. For the 'spot' type, these are the 'hotspot' and 'falloff angle' cosines. For the 'light' and 'shadow' types,
these are the TR units for the 'hotspot / falloff' (1024 = 1 sector).

`RadIn`, `RadOut` and `Range` are only used by the 'spot' light type.

`dx`, `dy` and `dz` values are used only by the 'sun' and 'spot' type lights. They describe the directional vector of the light. This can be obtained by:

* if both `x` and `y` latexmath:[$\mathnormal{LightDirectionVectorX} = \cos(X) * \sin(Y)$]
* latexmath:[$\mathnormal{LightDirectionVectorY} = \sin(X)$]
* latexmath:[$\mathnormal{LightDirectionVectorZ} = \cos(X) * \cos(Y)$]

`x2`, `y2`, `z2`, `dx2`, `dy2` and `dz2` values repeat previous corresponding information in long data types instead of floats.

Room Vertex structure
+++++++++++++++++++++

This defines the vertices within a room. As mentioned above, room lighting is internal vertex lighting, except for necessarily external sources like flares,
flame emitters and gunflashes. Room ambient lights and point sources are ignored.

As TR3 introduced colored lighting, room vertex structure drastically changed. It changed once again in TR5, when floating-point numbers were introduced. So
we'll define vertex structure for TR1-2, TR3-4 and TR5 independently.

.TR1-2 Room Vertex structure

[[tr_room_vertex]]
[source,cpp]
----
struct tr_room_vertex  // 8 bytes
{
     tr_vertex Vertex;
       int16_t Lighting;
};
----

`Vertex` is the coordinates of the vertex, relative to <<tr_room_info>> `x` and `z` values.

`Lighting` ranges from 0 (bright) to 0x1FFF (dark). This value is ignored by TR2, and `Lighting2` is used instead with the same brightness range.

TR2 uses an extended version of the structure:

[[tr2_room_vertex]]
[source,cpp]
----
struct tr2_room_vertex  // 12 bytes
{
     tr_vertex Vertex;
       int16_t Lighting;
      uint16_t Attributes; // A set of flags for special rendering effects
       int16_t Lighting2;  // Almost always equal to Lighting1
};
----

`Attributes` field is a 'set of flags', and their meaning is:

* 'Bits 0..4' are only used together in combination with the `LightMode` field of the <<tr_room>> structure. See below.
* 'Bit 15:' When used in room filled with water, don't move the vertices of the room when viewed from above (normally, when viewed from above, the vertices of a
  room filled with water moves to 'simulate' the refraction of lights in water). Note that when viewed from inside the room filled with water, the vertices of the
  other rooms outside still moves.

`Lighting` field is ignored by TR2, and `Lighting2` is used instead with the same brightness range -- from 0 (bright) to 0x1FFF (dark).

.TR3-4 Room Vertex structure

[source,cpp]
----
struct tr3_room_vertex  // 12 bytes
{
     tr_vertex Vertex;
       int16_t Lighting;   // Value is ignored!
      uint16_t Attributes; // A set of flags for special rendering effects
      uint16_t Colour;     // 15-bit colour
};
----

`Lighting` value is ignored by the engine, as now each vertex has its own defined 15-bit colour (see below).

`Attributes` bit flags were extended. Here is the list:

* 'Bit 4:' {TR3} Same meaning as in <<tr_room_vertex>>
* 'Bit 13:' Water / quicksand surface ``wave'' movement. Brightness is also shifting, if this flag is set (but it's not the same type as with 'Bit 14', it's much
  less noticeable).
* 'Bit 14:' Simulates caustics by constantly shifting vertex colour brightness. Used mainly in underwater rooms, but can be used in rooms without water. In TR2,
  there was a similar effect, but it was assigned for all vertices in any water room.
* 'Bit 15:' Same ``wave'' effect as with 'Bit 13', but without light effect (?).

NOTE: The amplitude of the ``wave'' effect depends on `WaterScheme` value specified in room structure.

`Colour` value specifies vertex colour in 15-bit format (each colour occupies 5 bits). Therefore, each colour value's maximum is '31'. You can use this code to
get each colour:

* 'Red:' `((Colour & 0x7C00) >> 10)`
* 'Green:' `((Colour & 0x03E0) >> 5)`
* 'Blue:' `(Colour & 0x001F)`

.TR5 Room Vertex structure

In TR5, room vertex structure was almost completely changed. Coordinates were converted to floats, and normal was added:

[[tr5_room_vertex]]
[source,cpp]
----
struct tr5_room_vertex  // 28 bytes
{
    tr5_vertex Vertex;     // Vertex is now floating-point
    tr5_vertex Normal;
      uint32_t Colour;     // 32-bit colour
};
----

There is no more `Attributes` field in room vertex structure for TR5.


Room Sprite structure
+++++++++++++++++++++

[source,cpp]
----
struct tr_room_sprite  // 4 bytes
{
    int16_t Vertex;       // Offset into vertex list
    int16_t Texture;      // Offset into sprite texture list
};
----

`Vertex` indicates an index into room vertex list (`Room.Vertices[room_sprite.Vertex]`), which acts as a point in space where to display a sprite.

`Texture` is an index into the sprite texture list.


Room Data structure
+++++++++++++++++++

This is the whole geometry of the ``room,'' including walls, floors, ceilings, and other embedded landscape. It 'does not' include objects that Lara can
interact with (keyholes, moveable blocks, moveable doors, etc.), neither does it include 'static meshes' (mentioned below in the next section).

The surfaces specified here are rendered surfaces.

CAUTION: This is not a ``real'' C/C++ structure, in that the arrays are sized by the `NumXXX` elements that precede them. Also <<tr_room_vertex>> could be
replaced by any other version-specific room vertex type (`tr3_room_vertex`, etc.).

[source,cpp]
----
virtual struct tr_room_data    // (variable length)
{
    int16_t NumVertices;                   // Number of vertices in the following list
    tr2_room_vertex Vertices[NumVertices]; // List of vertices (relative coordinates)

    int16_t NumRectangles;                 // Number of textured rectangles
    tr_face4 Rectangles[NumRectangles];   // List of textured rectangles

    int16_t NumTriangles;                  // Number of textured triangles
    tr_face3 Triangles[NumTriangles];     // List of textured triangles

    int16_t NumSprites;                    // Number of sprites
    tr2_room_sprite Sprites[NumSprites];   // List of sprites
};
----

Room Static Mesh structure
++++++++++++++++++++++++++

Positions and IDs of static meshes (e.g. skeletons, spiderwebs, furniture, trees). This is comparable to the <<tr2_item>> structure, except that static meshes
have no animations and are confined to a single room.

.TR1 Room Static Mesh structure

[source,cpp]
----
struct tr_room_staticmesh  // 18 bytes
{
    uint32_t x, y, z;    // Absolute position in world coordinates
    uint16_t Rotation;
    uint16_t Intensity1;
    uint16_t MeshID;     // Which StaticMesh item to draw
};
----

`Intensity1` ranges from 0 (bright) to 0x1FFF (dark).

In `Rotation` field, high two bits (`0xC000`) indicate steps of 90 degrees (e.g. (Rotation >> 14) * 90). However, when parsing this value, no extra bitshifting
is needed, as you can simply interpret it using this formula:

[source,cpp]
----
float Real_Rotation = (float)Rotation / 16384.0f * -90;
----

TR2 again uses an extended version:

[source,cpp]
----
struct tr2_room_staticmesh  // 20 bytes
{
    uint32_t x, y, z;    // Absolute position in world coordinates
    uint16_t Rotation;
    uint16_t Intensity1;
    uint16_t Intensity2; // Absent in TR1
    uint16_t MeshID;     // Which StaticMesh item to draw
};
----

`Intensity2` is seemingly not used, as changing this value does nothing.

.TR3-5 Room Static Mesh structure

[source,cpp]
----
virtual struct tr3_room_staticmesh  // 20 bytes
{
    uint32_t x, y, z;    // Absolute position in world coordinates
    uint16_t Rotation;
    uint16_t Colour;     // 15-bit colour
    uint16_t Unused;     // Not used!
    uint16_t MeshID;     // Which StaticMesh item to draw
};
----

`Colour` value specifies vertex colour in 15-bit format (each colour occupies 5 bits): 0x0[red]RRRRR[green]GGGGG[blue]BBBBB. Therefore, each colour value's
maximum is '31'. You can use this code to get each colour:

* 'Red:' `((Colour & 0x7C00) >> 10)`
* 'Green:' `((Colour & 0x03E0) >> 5)`
* 'Blue:' `(Colour & 0x001F)`

TR5 room structure changes
~~~~~~~~~~~~~~~~~~~~~~~~~~

In TR5 the room format was drastically changed. The room itself is made up of 'sections'. These sections encompass a 3x3 sector grid (actually 3069x3069
pixels). Historically, these sections are referred as 'layers', however, more proper name for them is 'volumes'. Layers are organized in a quadtree-like
structure, and their purpose was presumably optimizing rendering by some kind of space partitioning and culling invisible volumes.

Another thing to note is that some 'rooms' in TR5 do not actually contain visible mesh data. If concerned, we will refer to these rooms as 'null rooms'.

TR5 Room Layer structure
^^^^^^^^^^^^^^^^^^^^^^^^

[source,cpp]
----
struct tr5_room_layer   // 56 bytes
{
    uint32_t NumLayerVertices;   // Number of vertices in this layer (4 bytes)
    uint16_t UnknownL1;
    uint16_t NumLayerRectangles; // Number of rectangles in this layer (2 bytes)
    uint16_t NumLayerTriangles;  // Number of triangles in this layer (2 bytes)
    uint16_t UnknownL2;

    uint16_t Filler;             // Always 0
    uint16_t Filler2;            // Always 0

    // The following 6 floats define the bounding box for the layer

    float    LayerBoundingBoxX1;
    float    LayerBoundingBoxY1;
    float    LayerBoundingBoxZ1;
    float    LayerBoundingBoxX2;
    float    LayerBoundingBoxY2;
    float    LayerBoundingBoxZ2;

    uint32_t Filler3;     // Always 0 (4 bytes)
    uint32_t UnknownL6;   // Unknown
    uint32_t UnknownL7;   // Unknown
    uint32_t UnknownL8;   // Always the same throughout the level.
}
----

`UnknownL2` appears to be the number of double sided textures in this layer, however is sometimes 1 off (2 bytes).

The whole Room structure
~~~~~~~~~~~~~~~~~~~~~~~~

Here's where all the room data come together.

Room structure differs drastically across different game versions (especially in TR5). For this reason, we will define each version of Room structure
independently, to avoid confusion. Also, version-specific fields will be described in each version's section in a ``backwards-compatible'' manner, while common
fields with version-specific variations, such as `Flags`, will be described afterwards in separate section.

'These are not ``real'' C/C++ structures, in that the arrays are sized by the `NumXXX` elements that precede them.'

TR1 Room structure
^^^^^^^^^^^^^^^^^^

As it's stored in the file, the <<tr_room_info>> structure comes first, followed by a `uint32_t NumDataWords`, which specifies the number of 16-bit words to
follow.  Those data words must be parsed in order to interpret and construct the variable-length arrays of vertices, meshes, doors, and sectors. Such setup is
also applicable to all variations of room structures, 'except' `tr5_room`, which will be described independently.

[[tr_room]]
[source,cpp]
----
virtual struct tr_room  // (variable length)
{
    tr_room_info info;           // Where the room exists, in world coordinates

    uint32_t NumDataWords;       // Number of data words (uint16_t's)
    uint16_t Data[NumDataWords]; // The raw data from which the rest of this is derived

    tr_room_data RoomData;       // The room mesh

    uint16_t NumPortals;                 // Number of visibility portals to other rooms
    tr_room_portal Portals[NumPortals];  // List of visibility portals

    uint16_t NumZsectors;                                  // ``Width'' of sector list
    uint16_t NumXsectors;                                  // ``Height'' of sector list
    tr_room_sector SectorList[NumXsectors * NumZsectors];  // List of sectors in this room

    int16_t AmbientIntensity;

    uint16_t NumLights;                 // Number of lights in this room
    tr_room_light Lights[NumLights];    // List of lights

    uint16_t NumStaticMeshes;                            // Number of static meshes
    tr2_room_staticmesh StaticMeshes[NumStaticMeshes];   // List of static meshes

    int16_t AlternateRoom;
    int16_t Flags;
};
----

`AmbientIntensity` is a brightness value which affects only 'externally-lit' objects. It ranges from 0 (bright) to 0x1FFF (dark).

`AlternateRoom` (or, as it is called in TRLE terms, 'flipped room') is the number of the room that this room can 'flip' with. In the terms of the gameplay,
'flipped' room is a state change of the same room -- for example, empty or flooded with water, filled with sand or debris. Alternate room usually has the same
boundaries as original room, but altered geometry and/or texturing. Detailed description of 'alternate rooms' will be provided in a separate section.

TR2 Room structure
^^^^^^^^^^^^^^^^^^

[source,cpp]
----
virtual struct tr2_room  // (variable length)
{
    tr_room_info info;           // Where the room exists, in world coordinates

    uint32_t NumDataWords;       // Number of data words (uint16_t's)
    uint16_t Data[NumDataWords]; // The raw data from which the rest of this is derived

    tr_room_data RoomData;       // The room mesh

    uint16_t NumPortals;                 // Number of visibility portals to other rooms
    tr_room_portal Portals[NumPortals];  // List of visibility portals

    uint16_t NumZsectors;                                  // ``Width'' of sector list
    uint16_t NumXsectors;                                  // ``Height'' of sector list
    tr_room_sector SectorList[NumXsectors * NumZsectors];  // List of sectors in this room

    int16_t AmbientIntensity;
    int16_t AmbientIntensity2;  // Usually the same as AmbientIntensity
    int16_t LightMode;

    uint16_t NumLights;                 // Number of point lights in this room
    tr_room_light Lights[NumLights];    // List of point lights

    uint16_t NumStaticMeshes;                            // Number of static meshes
    tr_room_staticmesh StaticMeshes[NumStaticMeshes];   // List of static meshes

    int16_t AlternateRoom;
    int16_t Flags;
};
----

`AmbientIntensity2` value is usually equal to `AmbientIntensity` value. Seems it's not used.

`LightMode` specifies lighting mode special effect, which is applied to all room vertices 'in conjunction with 5 lowest bits of `Attributes` field belonging to
<<tr_room_vertex>> structure. Here we will refer these 5 bits' value to as 'effect_value:'

* *0* -- Normal lighting mode, no special effects.
* *2* -- If 'effect_value' is in 1-15 range, then vertex lighting is cyclically fading to more bright value. The lower the value is, the deeper the fade to full
  vertex lighting is. If 'effect_value' is in 17-30 range ('not' 31!), then vertex lighting is cyclically fading to more dark value. The higher the value is, the
  deeper the fade to black is. If 'effect_value' is 16 or 0, no effect is produced. So practically, 'effect_value' serves as a multiplier to overall effect
  brightness.
* *1* -- Produces flickering effect, with 'effect_value' acting the same way -- as intensity multiplier.


TR3 Room Structure
^^^^^^^^^^^^^^^^^^

[source,cpp]
----
virtual struct tr3_room  // (variable length)
{
    tr_room_info info;           // Where the room exists, in world coordinates

    uint32_t NumDataWords;       // Number of data words (uint16_t's)
    uint16_t Data[NumDataWords]; // The raw data from which the rest of this is derived

    tr_room_data RoomData;       // The room mesh

    uint16_t NumPortals;                 // Number of visibility portals to other rooms
    tr_room_portal Portals[NumPortals];  // List of visibility portals

    uint16_t NumZsectors;                                  // ``Width'' of sector list
    uint16_t NumXsectors;                                  // ``Height'' of sector list
    tr_room_sector SectorList[NumXsectors * NumZsectors];  // List of sectors in this room

    int16_t AmbientIntensity1;  // This and the next one only affect externally-lit objects
    int16_t AmbientIntensity2;  // Usually the same as AmbientIntensity1

    uint16_t NumLights;                 // Number of point lights in this room
    tr3_room_light Lights[NumLights];   // List of point lights

    uint16_t NumStaticMeshes;                            // Number of static meshes
    tr_room_staticmesh StaticMeshes[NumStaticMeshes];    // List of static meshes

    int16_t AlternateRoom;
    int16_t Flags;

    uint8_t WaterScheme;
    uint8_t ReverbInfo;

    uint8_t Filler;  // Unused.
};
----

TR4 Room Structure
^^^^^^^^^^^^^^^^^^

[source,cpp]
----
virtual struct tr4_room  // (variable length)
{
    tr_room_info info;           // Where the room exists, in world coordinates

    uint32_t NumDataWords;       // Number of data words (uint16_t's)
    uint16_t Data[NumDataWords]; // The raw data from which the rest of this is derived

    tr_room_data RoomData;       // The room mesh

    uint16_t NumPortals;                 // Number of visibility portals to other rooms
    tr_room_portal Portals[NumPortals];  // List of visibility portals

    uint16_t NumZsectors;                                  // ``Width'' of sector list
    uint16_t NumXsectors;                                  // ``Height'' of sector list
    tr2_room_sector SectorList[NumXsectors * NumZsectors]; // List of sectors in this room

    uint32_t RoomColour;        // In ARGB format!

    int16_t AmbientIntensity1;  // This and the next one only affect externally-lit objects
    int16_t AmbientIntensity2;  // Usually the same as AmbientIntensity1

    uint16_t NumLights;                 // Number of point lights in this room
    tr4_room_light Lights[NumLights];   // List of point lights

    uint16_t NumStaticMeshes;                           // Number of static meshes
    tr_room_staticmesh StaticMeshes[NumStaticMeshes];   // List of static meshes

    int16_t AlternateRoom;
    int16_t Flags;

    uint8_t WaterScheme;
    uint8_t ReverbInfo;

    uint8_t AlternateGroup;  // Replaces Filler from TR3
};
----

`RoomColour` replaces `AmbientIntensity` and `AmbientIntensity2` values from `tr2_room` structure. Note it's 'not in `tr_colour4` format', because colour order
is reversed. It should be treated as ARGB, where A is unused.

`AlternateGroup` was introduced in TR4 to solve long-existing engine limitation, which flipped 'all alternate rooms at once' (see 'flipmap' trigger function
description in <<trigger-functions,Trigger Functions>> section). Since TR4, engine only flips rooms which have similar index in room's `AlternateGroup` field
and trigger operand.

TR5 Room Structure
^^^^^^^^^^^^^^^^^^

As it was mentioned before, TR5 room structure was almost completely changed, when compared to previous versions. For example, TR5 completely throws out a
concept of `tr_room_data` structure, shuffles numerous values and structures in almost chaotic manner, and introduces a bunch of completely new parameters
(mostly to deal with 'layers'). Also, there is vast amount of 'fillers' and 'separators', which contain no specific data.

NOTE: The one possible reason for such ridiculous structure change is an attempt to 'crypt file format', so it won't be accessed by unofficial level editing tools, which received major development by that time. Another possible reason is whole TR5 development process was rushed, as the team developed 'Tomb Raider: Angel of Darkness' at the very same time.

[source,cpp]
----
virtual struct tr5_room // (variable length)
{
    char XELA[4];           // So-called "XELA landmark"

    uint32_t RoomDataSize;

    uint32_t Seperator;     // 0xCDCDCDCD (4 bytes)

    uint32_t EndSDOffset;
    uint32_t StartSDOffset;

    uint32_t Separator;     // Either 0 or 0xCDCDCDCD

    uint32_t EndPortalOffset;

    tr_room_info info;

    uint16_t NumZSectors;
    uint16_t NumXSectors;

    uint32_t RoomColour;   // In ARGB format!

    uint16_t NumLights;
    uint16_t NumStaticMeshes;

    uint8_t  ReverbInfo;
    uint8_t  AlternateGroup;
    uint16_t WaterScheme;

    uint32_t Filler[2];    // Both always 0x00007FFF
    uint32_t Separator[2]; // Both always 0xCDCDCDCD
    uint32_t Filler;       // Always 0xFFFFFFFF

    uint16_t AlternateRoom;
    uint16_t Flags;

    uint32_t Unknown1;
    uint32_t Unknown2;     // Always 0
    uint32_t Unknown3;     // Always 0

    uint32_t Separator;    // 0xCDCDCDCD

    uint16_t Unknown4;
    uint16_t Unknown5;

    float RoomX;
    float RoomY;
    float RoomZ;

    uint32_t Separator[4]; // Always 0xCDCDCDCD
    uint32_t Separator;    // 0 for normal rooms and 0xCDCDCDCD for null rooms
    uint32_t Separator;    // Always 0xCDCDCDCD

    uint32_t NumRoomTriangles;
    uint32_t NumRoomRectangles;

    uint32_t Separator;     // Always 0

    uint32_t LightDataSize;
    uint32_t NumLights2;    // Always same as NumLights

    uint32_t Unknown6;

    int32_t RoomYTop;
    int32_t RoomYBottom;

    uint32_t NumLayers;

    uint32_t LayerOffset;
    uint32_t VerticesOffset;
    uint32_t PolyOffset;
    uint32_t PolyOffset2;   // Same as PolyOffset

    uint32_t NumVertices;

    uint32_t Separator[4];  // Always 0xCDCDCDCD

    tr5_room_light Lights[NumLights];    // Data for the lights (88 bytes * NumRoomLights)
    tr2_room_sector SectorList[NumXSectors * NumZSectors]; // List of sectors in this room

    uint16_t NumPortals;                 // Number of visibility portals to other rooms
    tr_room_portal Portals[NumPortals];  // List of visibility portals

    uint16_t Separator;  // Always 0xCDCD

    tr3_room_staticmesh StaticMeshes[NumStaticMeshes];   // List of static meshes

    tr5_room_layer[NumLayers]; // Data for the room layers (volumes) (56 bytes * NumLayers)

    uint8_t Faces[(NumRoomRectangles * sizeof(tr_face4) + NumRoomTriangles * (tr_face3)];

    tr5_room_vertex Vertices[NumVertices];
}
----

`XELA` landmark seemingly serves as a header for room structure. It is clear that 'XELA' is a reversed 'ALEX', which is most likely the name of TR5 programmer,
'Alex Davis'. It probably indicates that Alex Davis is responsible for changes in room structures.

`RoomDataSize` is a handy value determining the size of the following data. You can use this value to quickly 'parse thru' to the next room.

`EndSDOffset`: usually this number `+216` will give you the offset from the start of the room data to the end of the `SectorData` section. However, it is known
that this uint32_t could be equal to `0xFFFFFFFF`, so to calculate the end of `SectorData`, it is better to use the following value `StartSDOffset + 216 +
((NumXSectors * NumZSectors)*8)`, if you need to obtain this information.

`StartSDOffset`: This number `+216` will give you the offset from the start of the room to the start of the `SectorData` section.

`EndPortalOffset`: this number `+216` will give you the offset from the start of the room to the end of the portal data.

`RoomX`, `RoomY` and `RoomZ` values are positions of room in world coordinates. *NOTE:* If room is 'null room', then each of these values will be `0xCDCDCDCD`.

`NumRoomTriangles` and `NumRoomRectangles` are respectively the numbers of triangular and rectangular faces in a given room. *NOTE:* If room is 'null room',
each of these values will be `0xCDCDCDCD`.

`LightDataSize` is the size of the light data in bytes ('not' in `tr5_room_light` units).

`Unknown6` could probably be a copy of `ReverbInfo` (see further), as its value usually ranges from 0 to 3.

`RoomYTop` and `RoomYBottom` are equal to `yTop` and `yBottom` values in <<tr_room_info>> structure. If room is a 'null room', both of these values are
`0xCDCDCDCD`.

`NumLayers` is a number of layers (volumes) in this room.

`LayerOffset`: this number `+216` will give you an offset from the start of the room data to the start of the layer data.

`VerticesOffset`: this number `+216` will give you an offset from the start of the room data to the start of the verex data.

`PolyOffset`: this number `+216` will give you an offset from the start of the room data to the start of the rectangle/triangle data.

`VerticesSize` is the size of vertex data block in bytes. Therefore, it 'must' be a multiple of `tr5_room_vertex` size, else it means the block size is wrong.

`Faces` is a sequential data array for the room polygons (both `tr_face4` and `tr_face3`),

NOTE: `Faces` array is strictly linked with `NumLayers` value. The data is sequentially structured for each layer -- at first it lists first layer's rectangles
then triangles, followed by the second layer's rectangles and triangles, and so on, until all layers are done.

Common fields of a room structure
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

`Flags` is an array of various flag bits, which meaning is as follows:

* 'Bit 0' -- Room is filled with water.
* 'Bit 3' -- {TR2}{TR3}{TR4}{TR5} Set if the 'skybox' can be seen from this room. Used to speed things up: if no rendered room has this bit set, then the sky can
  never been seen, so it is not rendered. Else, if at least one visible room has this bit set, then the sky must be drawn because it is (could be) visible.
* 'Bit 5' -- {TR2}{TR3}{TR4}{TR5} Lara's ponytail gets blown by the wind. Beginning with TR3, some particle types are also be blown, if they end up in such room
  (particle type is specified by certain particle flag).
* 'Bit 6' -- {TR3}{TR4}{TR5} Unknown. A lot of rooms have this bit set but it seems it does nothing...
* 'Bit 7' -- {TR3}{TR4}{TR5} Different meaning in TR3 and TR4/5. In TR3, it means that room is filled with quicksand, while in TR4/5 it presumably blocks 'global
  lens flare' from appearing in that room (in TRLE, checkbox which sets this flag is named 'NL').
* 'Bit 8' -- In TR1, the meaning is unknown. In TR3-5, it is presumably 'mist room'. TRLE sets this bit when the M ('mist') option is used (in the same time, the
  amount of mist typed by the user is put in the `water_scheme` byte). Unknown effect on the rendering / the game -- probably, the feature was never implemented
  in final version.
* 'Bit 9' -- {TR3}{TR4}{TR5} The room has some 'water reflectivity'. TRLE sets this bit when the R ('reflectivity') option is used (in the same time, the amount
  of reflectivity typed by the user + 5 is put in the `water_scheme` byte). When the flag is set for normal room and there is water room below it, game engine
  creates ``reflection effect'' above the water surface -- effectively it means that all the vertices at the bottom of the room receive caustics effect described
  well above.
* 'Bit 11' -- {TR4}{TR5} Not found in any original TR levels, but when the 'D' flag is set in the TRLE, this bit is set. Was re-used in NGLE as a flag specifying
  'Damage room'.
* 'Bit 12' -- {TR4}{TR5} Not found in any original TR levels, but when the 'P' flag is set in the TRLE, this bit is set. Was also re-used in NGLE as a flag
  specifying 'Poisonous room'.

{TR3}{TR4}{TR5} `WaterScheme` is used for different purposes. If room is a water room, then it specifies underwater caustics patterns. If it is set for normal
room 'placed above the water room', then it controls 'wave strength' effect applied to the faces adjoining water room. Maximum value in both cases is 15.

{TR3}{TR4}{TR5} `ReverbInfo` defines 'room reverberation type'. It affects sound postprocessing, if listener position belongs to that room. This feature was
present 'only in PlayStation versions' of the game, but not on PC. Nevertheless, the info is preserved in PC level files. Here are the types of reverberation:

* *0* -- Outside. No (or barely heard) reverberation.
* *1* -- Small room. Little reverberation.
* *2* -- Medium room.
* *3* -- Large room.
* *4* -- Pipe. Highest reverberation level. Almost never used.
